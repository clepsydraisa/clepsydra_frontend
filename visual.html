<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visualização - Clepsydra Project</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
    <!-- Leaflet CSS/JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Proj4js para converter coordenadas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        background: #f3f4f6;
      }
      .ai-btn {
        background-size: 200% 100%;
        background-position: left center;
        transition: background-position 0.4s cubic-bezier(0.4, 0, 0.2, 1),
          transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .ai-btn:hover {
        background-position: right center;
        transform: scale(1.07);
      }
      .ai-btn:active {
        transform: scale(0.96);
      }
      #chart-modal {
        z-index: 9999 !important;
        position: fixed !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.4);
      }
      #chart-modal .bg-white {
        z-index: 10000 !important;
        max-width: 98vw;
        max-height: 98vh;
        overflow-y: auto;
        position: relative;
      }
      #chart-modal .flex-row {
        flex-wrap: wrap;
      }
      #wellChart {
        max-width: 70vw;
        max-height: 70vh;
      }
      .leaflet-container {
        z-index: 0 !important;
      }
      #chart-modal.hidden {
        display: none !important;
      }
      #chart-modal button.absolute.top-2.right-2 {
        z-index: 10100;
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
      }
      /* Estilos para análise de tendência */
      .trend-title {
        font-size: 1.2rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
      }
      .trend-period-card {
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
      }
      .trend-type-up {
        color: #6b7280;
        font-weight: bold;
      }
      .trend-type-down {
        color: #6b7280;
        font-weight: bold;
      }
      .trend-type-none {
        color: #6b7280;
        font-weight: bold;
      }
      .trend-value {
        font-size: 1.1em;
        margin-top: 0.2em;
      }
      /* Estilo para a tabela de info ocupar toda a largura */
      #infoTableBox {
        width: 100%;
        max-width: 100%;
      }
      #infoTableBox table {
        width: 100%;
        table-layout: auto;
      }
      #infoTableBox th, #infoTableBox td {
        white-space: nowrap;
        text-align: left;
      }
      .show-chart-btn {
        background: none;
        border: none;
        color: #2563eb;
        font-size: 1.1em;
        cursor: pointer;
        margin-right: 0.3em;
        padding: 0 0.2em;
        vertical-align: middle;
        transition: color 0.2s;
      }
      .show-chart-btn:hover {
        color: #1d4ed8;
      }
      /* Header Navigation Styles */
      .nav-link {
        position: relative;
        transition: all 0.3s ease;
      }
      .nav-link::after {
        content: '';
        position: absolute;
        width: 0;
        height: 2px;
        bottom: -2px;
        left: 0;
        background-color: #174192;
        transition: width 0.3s ease;
      }
      .nav-link:hover::after {
        width: 100%;
      }
      .nav-link.active {
        font-weight: 600;
      }
      .nav-link.active::after {
        width: 100%;
      }
    </style>
  </head>
  <body class="flex flex-col min-h-screen">
    <!-- Header -->
    <header class="fixed top-0 left-0 w-full bg-white text-blue-900 py-4 px-6 shadow z-50">
      <div class="container mx-auto flex items-center justify-between">
        <div class="flex items-center space-x-4">
          <a href="https://clepsydra.interreg-euro-med.eu/" target="_blank">
            <img
              src="https://github.com/clepsydraisa/clepsydra_isa/blob/main/images/logo_c2.png?raw=true"
              alt="Clepsydra Logo"
              class="h-16 w-auto"
            />
          </a>
        </div>
        <nav class="flex-1">
          <div class="flex items-center justify-end space-x-6">
            <ul class="flex items-center space-x-6">
              <li>
                <a
                  href="index.html"
                  class="text-blue-900 nav-link font-medium text-sm flex items-center"
                >
                  <i class="fas fa-home"></i>
                </a>
              </li>
              <li>
                <a
                  href="about_c.html"
                  class="text-blue-900 nav-link font-medium text-sm"
                  >Sobre</a
                >
              </li>
              <li>
                <a
                  href="tarefas.html"
                  class="text-blue-900 nav-link font-medium text-sm"
                  >Tarefas</a
                >
              </li>
              <li>
                <a
                  href="parceiros.html"
                  class="text-blue-900 nav-link font-medium text-sm"
                  >Parceiros</a
                >
              </li>
              <li>
                <a
                  href="biblio_dados.html"
                  class="text-blue-900 nav-link font-medium text-sm"
                  >Biblioteca de Dados</a
                >
              </li>
              <li>
                <a
                  href="visual.html"
                  class="text-blue-900 nav-link font-semibold text-sm active"
                  >Visualização</a
                >
              </li>
              <li>
                <a
                  href="condicoesreais.html"
                  class="text-blue-900 nav-link font-medium text-sm"
                  >Condições Reais</a
                >
              </li>
            </ul>
            <button
              class="ai-btn bg-gradient-to-r from-blue-700 via-blue-600 to-blue-800 text-white font-medium text-sm py-2 px-4 rounded shadow focus:outline-none"
            >
              Modelo AI
            </button>
          </div>
        </nav>
      </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow w-full py-12 pt-24">
      <div class="container mx-auto px-6 mt-6">
        <!-- Breve texto explicativo -->
        <div class="mb-6 text-gray-700 text-base font-normal">
          Foi criada uma interface gráfica orientada para o utilizador, que permite explorar de forma dinâmica as tendências históricas das variáveis relevantes.
        </div>
        <!-- Filtro de variáveis -->
        <div class="mb-4 flex items-center space-x-2">
          <label for="variableFilter" class="font-semibold text-blue-900"
            >Variável:</label
          >
          <select
            id="variableFilter"
            class="border border-blue-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-400"
          >
            <option value="profundidade">Profundidade</option>
            <option value="nitrato">Nitratos</option>
            <option value="precipitacao">Precipitação</option>
            <option value="rega">Rega</option>
            <option value="temperaturas">Temperaturas</option>
            <option value="caudal">Caudal</option>
          </select>
          <label for="wellFilter" class="font-semibold text-blue-900 ml-4"
            >Pontos:</label
          >
          <select
            id="wellFilter"
            class="border border-blue-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-400 min-w-[100px]"
          >
            <option value="">Todos</option>
          </select>
        </div>
        <div id="map" style="height: 500px"></div>
        <div class="mt-2 flex flex-col items-start">
          <button id="infoBtn" class="px-4 py-2 bg-gray-100 text-blue-800 rounded hover:bg-gray-200 font-semibold transition">
            + Info
          </button>
          <div id="infoTableBox" class="hidden mt-2"></div>
        </div>
      </div>
    </main>

    <!-- Modal deve estar FORA do container do mapa -->
    <div id="chart-modal" class="hidden">
      <div class="bg-white p-6 rounded shadow-lg relative">
        <button
          onclick="closeModal()"
          class="absolute top-2 right-2 text-gray-500 text-2xl"
        >
          &times;
        </button>
        <h2 id="well-title" class="text-lg font-bold mb-2"></h2>
        <div class="mb-2 text-sm text-gray-600">
          Use o <b>scroll do mouse</b> para dar zoom,
          <b>clique e arraste</b> para selecionar uma área.<br />
          <button
            id="resetZoomBtn"
            class="mt-2 px-3 py-1 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 transition"
          >
            Resetar Zoom
          </button>
          <button
            id="trendAnalysisBtn"
            class="mt-2 ml-2 px-3 py-1 bg-green-100 text-green-800 rounded hover:bg-green-200 transition hidden"
          >
            Análise de tendência
          </button>
        </div>
        <div class="flex flex-row">
          <canvas id="wellChart" width="400" height="300"></canvas>
          <div
            id="trendStatsBox"
            class="ml-6 p-4 bg-gray-50 border border-gray-200 rounded shadow text-xs hidden"
            style="min-width: 220px; max-width: 320px"
          ></div>
        </div>
      </div>
    </div>

    <!-- Friso colorido estreito acima do footer -->
    <div
      class="w-full h-8"
      style="
        background: linear-gradient(
          to right,
          #17479e,
          #0e6bb5,
          #0093d3,
          #5a5a8c,
          #c1272d,
          #ff6f1f,
          #d6b08c,
          #a3bfa8,
          #4a2c0a
        );
      "
    ></div>

    <!-- Footer -->
    <footer class="bg-white py-4 px-6 shadow">
      <div
        class="container mx-auto flex justify-center items-center min-h-[80px]"
      >
        <img
          src="https://github.com/clepsydraisa/clepsydra_isa/blob/main/images/logo_footer_c.png?raw=true"
          alt="Logos rodapé"
          class="w-auto h-12"
        />
      </div>
    </footer>

    <script>
      // Definição dos sistemas de coordenadas
      proj4.defs(
        "ESRI:102164",
        "+proj=tmerc +lat_0=39.66666666666666 +lon_0=-8.131906111111112 +k=1 +x_0=200000 +y_0=300000 +ellps=intl +units=m +no_defs"
      );
      const fromProj = "ESRI:102164";
      const toProj = "WGS84";

      // Função para converter coordenadas
      function convertCoords(x, y) {
        return proj4(fromProj, toProj, [parseFloat(x), parseFloat(y)]);
      }

      // Função para fechar o modal
      function closeModal() {
        document.getElementById("chart-modal").classList.add("hidden");
      }

      // Variáveis globais para mapa e marcadores
      let map, markersLayer;
      let wellsData = null;
      let nitratoData = null;
      let precipData = null;
      let regaData = null; // Add irrigation data variable
      let tempData = null; // Add temperature data variable
      let caudalData = null; // Add caudal data variable

      // Inicializar o mapa
      function initMap() {
        if (map) return;
        map = L.map("map").setView([39.5, -8], 8);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OpenStreetMap contributors",
        }).addTo(map);
        markersLayer = L.layerGroup().addTo(map);
      }

      // Função para limpar marcadores
      function clearMarkers() {
        if (markersLayer) markersLayer.clearLayers();
      }

      // Adiciona a função utilitária para formatar o texto da análise de tendência
      function getTrendDescription(seg, idx, variable) {
        // Tradução e cor do tipo de tendência
        let trendType = seg.trend_type;
        let trendClass = "trend-type-none";
        let trendValue = seg.slope_per_year;

        if (variable === 'profundidade') {
          if (trendType === "decreasing") {
            trendType = "Aumento da profundidade";
            trendClass = "trend-type-down";
          } else if (trendType === "increasing") {
            trendType = "Diminuição da profundidade";
            trendClass = "trend-type-up";
          } else {
            trendType = "Sem mudança significativa";
          }
          if (trendValue !== null) {
            trendValue = Math.abs(trendValue);
          }
        } else { // Logic for other variables (nitrato)
          if (trendType === "decreasing") {
            trendType = "Tendência Decrescente";
            trendClass = "trend-type-down";
          } else if (trendType === "increasing") {
            trendType = "Tendência Crescente";
            trendClass = "trend-type-up";
          } else {
            trendType = "Sem tendência";
          }
        }

        // Unidade com expoente
        let unit = variable === "profundidade"
          ? "m ano<sup>-1</sup>"
          : "mg/L ano<sup>-1</sup>";

        return `
          <div class="trend-period-card">
            <div><b>Período ${idx + 1}:</b> ${seg.start_date} a ${seg.end_date}</div>
            <div class="${trendClass}">${trendType}</div>
            <div class="trend-value">${trendValue !== null ? trendValue.toFixed(3) : "-"} ${unit}</div>
          </div>
        `;
      }

      // Função para desenhar marcadores de profundidade
      function drawProfundidadeMarkers() {
        clearMarkers();
        Object.entries(wellsData).forEach(([codigo, well]) => {
          const marker = L.circleMarker(well.coord, {
            radius: 6,
            color: "#007bff",
            fillColor: "#007bff",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById("well-title").innerText = `Poço ${codigo}`;
            document.getElementById("trendAnalysisBtn").textContent =
              "Análise de tendência";
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            window.currentChart = new Chart(ctx, {
              type: "line",
              data: {
                datasets: [
                  {
                    label: "Profundidade Nível Água (m)",
                    data: well.data.map((d) => ({
                      x: d.date,
                      y: d.profundidade,
                    })),
                    borderColor: "#007bff",
                    backgroundColor: "rgba(0,123,255,0.2)",
                    fill: "start",
                    tension: 0.2,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    type: "time",
                    time: {
                      unit: "year",
                      tooltipFormat: "yyyy-MM-dd",
                    },
                    title: { display: true, text: "Data" },
                  },
                  y: {
                    title: { display: true, text: "Profundidade (m)" },
                    reverse: true,
                    min: 0,
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
            // Mostrar botão de análise de tendência apenas para piezometria
            document
              .getElementById("trendAnalysisBtn")
              .classList.remove("hidden");
            document.getElementById("trendStatsBox").classList.add("hidden");
            document.getElementById("trendStatsBox").innerHTML = "";
            let trendVisible = false;
            document.getElementById("trendAnalysisBtn").onclick =
              async function () {
                if (!trendVisible) {
                  const jsonUrl = `resources/trends/trends_piezo/trend_${codigo.replace(
                    "/",
                    "_"
                  )}.json`;
                  try {
                    const resp = await fetch(jsonUrl);
                    if (!resp.ok) throw new Error("Trend JSON não encontrado");
                    const trendData = await resp.json();
                    // Adicionar linhas de tendência ao gráfico
                    if (window.currentChart) {
                      const mainDataset =
                        window.currentChart.data.datasets.filter(
                          (ds) => !ds._isTrend
                        );
                      const trendDatasets = trendData.segments.map(
                        (seg, idx) => ({
                          label: `Período ${idx + 1}`,
                          data: seg.trend_points.map((p) => ({
                            x: p.x,
                            y: -p.y,
                          })),
                          borderColor: "#e67e22",
                          backgroundColor: "rgba(230,126,34,0.1)",
                          borderDash: [6, 3],
                          pointRadius: 0,
                          fill: false,
                          tension: 0,
                          _isTrend: true,
                          order: 99,
                          type: "line",
                        })
                      );
                      window.currentChart.data.datasets =
                        mainDataset.concat(trendDatasets);
                      window.currentChart.update();
                    }
                    // Mostrar estatísticas na box
                    let html = `<div class="trend-title">Análise de tendência</div>`;
                    trendData.segments.forEach((seg, idx) => {
                      html += getTrendDescription(seg, idx, "profundidade");
                    });
                    document.getElementById("trendStatsBox").innerHTML = html;
                    document
                      .getElementById("trendStatsBox")
                      .classList.remove("hidden");
                    trendVisible = true;
                    this.textContent = "Fechar análise de tendência";
                  } catch (e) {
                    document.getElementById("trendStatsBox").innerHTML =
                      '<span class="text-red-600">Erro ao carregar análise de tendência.</span>';
                    document
                      .getElementById("trendStatsBox")
                      .classList.remove("hidden");
                    trendVisible = true;
                    this.textContent = "Fechar análise de tendência";
                  }
                } else {
                  // Esconder linhas de tendência e box
                  if (window.currentChart) {
                    window.currentChart.data.datasets =
                      window.currentChart.data.datasets.filter(
                        (ds) => !ds._isTrend
                      );
                    window.currentChart.update();
                  }
                  document
                    .getElementById("trendStatsBox")
                    .classList.add("hidden");
                  document.getElementById("trendStatsBox").innerHTML = "";
                  trendVisible = false;
                  this.textContent = "Análise de tendência";
                }
              };
          });
        });
      }

      // Função para desenhar marcadores de nitrato
      function drawNitratoMarkers() {
        clearMarkers();
        Object.entries(nitratoData).forEach(([codigo, well]) => {
          const marker = L.circleMarker(well.coord, {
            radius: 6,
            color: "#28a745",
            fillColor: "#28a745",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById("well-title").innerText = `Poço ${codigo}`;
            document.getElementById("trendAnalysisBtn").textContent =
              "Análise de tendência";
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            // Ordenar os dados por data antes de plotar
            const sortedData = well.data
              .slice()
              .sort((a, b) => new Date(a.date) - new Date(b.date));
            window.currentChart = new Chart(ctx, {
              type: "scatter",
              data: {
                datasets: [
                  {
                    label: "Nitrato (mg/L)",
                    data: sortedData.map((d) => ({ x: d.date, y: d.nitrato })),
                    borderColor: "#28a745",
                    backgroundColor: "#28a745",
                    showLine: false,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    type: "time",
                    time: {
                      unit: "year",
                      tooltipFormat: "yyyy-MM-dd",
                    },
                    title: { display: true, text: "Data" },
                  },
                  y: {
                    title: { display: true, text: "Nitrato (mg/L)" },
                    min: 0,
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
            // Mostrar botão de análise de tendência para nitrato
            document
              .getElementById("trendAnalysisBtn")
              .classList.remove("hidden");
            document.getElementById("trendStatsBox").classList.add("hidden");
            document.getElementById("trendStatsBox").innerHTML = "";
            let trendVisible = false;
            document.getElementById("trendAnalysisBtn").onclick =
              async function () {
                if (!trendVisible) {
                  const jsonUrl = `resources/trends/trends_nitrato/trend_${codigo.replace(
                    "/",
                    "_"
                  )}.json`;
                  try {
                    const resp = await fetch(jsonUrl);
                    if (!resp.ok) throw new Error("Trend JSON não encontrado");
                    const trendData = await resp.json();
                    // Adicionar linhas de tendência ao gráfico
                    if (window.currentChart) {
                      const mainDataset =
                        window.currentChart.data.datasets.filter(
                          (ds) => !ds._isTrend
                        );
                      const trendDatasets = trendData.segments.map(
                        (seg, idx) => ({
                          label: `Período ${idx + 1}`,
                          data: seg.trend_points, // NÃO inverter sinal!
                          borderColor: "#e67e22",
                          backgroundColor: "rgba(230,126,34,0.1)",
                          borderDash: [6, 3],
                          pointRadius: 0,
                          fill: false,
                          tension: 0,
                          _isTrend: true,
                          order: 99,
                          type: "line",
                        })
                      );
                      window.currentChart.data.datasets =
                        mainDataset.concat(trendDatasets);
                      window.currentChart.update();
                    }
                    // Mostrar estatísticas na box
                    let html = `<div class="trend-title">Análise de tendência</div>`;
                    trendData.segments.forEach((seg, idx) => {
                      html += getTrendDescription(seg, idx, "nitrato");
                    });
                    document.getElementById("trendStatsBox").innerHTML = html;
                    document
                      .getElementById("trendStatsBox")
                      .classList.remove("hidden");
                    trendVisible = true;
                    this.textContent = "Fechar análise de tendência";
                  } catch (e) {
                    document.getElementById("trendStatsBox").innerHTML =
                      '<span class="text-red-600">Erro ao carregar análise de tendência.</span>';
                    document
                      .getElementById("trendStatsBox")
                      .classList.remove("hidden");
                    trendVisible = true;
                    this.textContent = "Fechar análise de tendência";
                  }
                } else {
                  // Esconder linhas de tendência e box
                  if (window.currentChart) {
                    window.currentChart.data.datasets =
                      window.currentChart.data.datasets.filter(
                        (ds) => !ds._isTrend
                      );
                    window.currentChart.update();
                  }
                  document
                    .getElementById("trendStatsBox")
                    .classList.add("hidden");
                  document.getElementById("trendStatsBox").innerHTML = "";
                  trendVisible = false;
                  this.textContent = "Análise de tendência";
                }
              };
          });
        });
      }

      // Função para desenhar marcadores de precipitação
      function drawPrecipMarkers() {
        clearMarkers();
        Object.entries(precipData).forEach(([codigo, station]) => {
          const marker = L.circleMarker(station.coord, {
            radius: 6,
            color: "#800080",
            fillColor: "#800080",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById(
              "well-title"
            ).innerText = `Estação ${codigo} - ${station.nome}`;
            document.getElementById("trendAnalysisBtn").textContent =
              "Análise de tendência";
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            // Ordenar os dados por data antes de plotar
            const sortedData = station.data
              .slice()
              .sort((a, b) => new Date(a.date) - new Date(b.date));
            window.currentChart = new Chart(ctx, {
              type: "line",
              data: {
                datasets: [
                  {
                    label: "Precipitação (mm)",
                    data: sortedData.map((d) => ({
                      x: d.date,
                      y: d.precipitacao,
                    })),
                    borderColor: "#800080",
                    backgroundColor: "rgba(128,0,128,0.2)",
                    fill: "start",
                    tension: 0.2,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    type: "time",
                    time: {
                      unit: "year",
                      tooltipFormat: "yyyy-MM-dd",
                    },
                    title: { display: true, text: "Data" },
                  },
                  y: {
                    title: { display: true, text: "Precipitação (mm)" },
                    min: 0,
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
            document.getElementById("trendAnalysisBtn").classList.add("hidden");
            document.getElementById("trendStatsBox").classList.add("hidden");
            document.getElementById("trendStatsBox").innerHTML = "";
          });
        });
      }

      // Função para desenhar marcadores de rega
      function drawRegaMarkers() {
        clearMarkers();
        Object.entries(regaData).forEach(([municipio, data]) => {
          const marker = L.circleMarker(data.coord, {
            radius: 6,
            color: "#ff6b1f",
            fillColor: "#ff6b1f",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById("well-title").innerText = `Município ${municipio}`;
            document.getElementById("trendAnalysisBtn").classList.add("hidden");
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            window.currentChart = new Chart(ctx, {
              type: "bar",
              data: {
                labels: data.data.map((d) => d.date),
                datasets: [
                  {
                    label: "Volume de Rega (hm³)",
                    data: data.data.map((d) => d.volume),
                    backgroundColor: "#ff6b1f",
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    title: { display: true, text: "Ano" },
                  },
                  y: {
                    title: { display: true, text: "Volume (hm³)" },
                    min: 0,
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
            document.getElementById("trendStatsBox").classList.add("hidden");
            document.getElementById("trendStatsBox").innerHTML = "";
          });
        });
      }

      // Função para desenhar marcadores de temperatura
      function drawTempMarkers() {
        clearMarkers();
        Object.entries(tempData).forEach(([locationKey, location]) => {
          const marker = L.circleMarker(location.coord, {
            radius: 6,
            color: "#dc3545",
            fillColor: "#dc3545",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById("well-title").innerText = `Localização ${locationKey.replace('_', ', ')}`;
            document.getElementById("trendAnalysisBtn").classList.add("hidden");
            
            // Criar botões para alternar entre temperatura máxima e mínima
            const trendStatsBox = document.getElementById("trendStatsBox");
            trendStatsBox.classList.remove("hidden");
            trendStatsBox.innerHTML = `
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Tipo de Temperatura:</label>
                <div class="flex space-x-2">
                  <button id="showTx" class="px-3 py-1 bg-red-100 text-red-800 rounded hover:bg-red-200 transition text-sm">
                    Temperatura Máxima
                  </button>
                  <button id="showTn" class="px-3 py-1 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 transition text-sm">
                    Temperatura Mínima
                  </button>
                </div>
              </div>
            `;
            
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            
            // Função para criar gráfico de temperatura
            function createTempChart(tempType) {
              const data = tempType === 'tx' ? location.data.map(d => ({ x: d.date, y: d.tx })) : location.data.map(d => ({ x: d.date, y: d.tn }));
              const label = tempType === 'tx' ? 'Temperatura Máxima (°C)' : 'Temperatura Mínima (°C)';
              const color = tempType === 'tx' ? '#dc3545' : '#007bff';
              
              window.currentChart = new Chart(ctx, {
                type: "scatter",
                data: {
                  datasets: [
                    {
                      label: label,
                      data: data,
                      borderColor: color,
                      backgroundColor: color,
                      showLine: false,
                      pointRadius: 4,
                      pointHoverRadius: 6,
                    },
                  ],
                },
                options: {
                  responsive: true,
                  scales: {
                    x: {
                      type: "time",
                      time: {
                        unit: "year",
                        tooltipFormat: "yyyy-MM-dd",
                      },
                      title: { display: true, text: "Data" },
                    },
                    y: {
                      title: { display: true, text: "Temperatura (°C)" },
                    },
                  },
                  plugins: {
                    zoom: {
                      pan: { enabled: true, mode: "x", modifierKey: null },
                      zoom: {
                        enabled: true,
                        mode: "x",
                        drag: { enabled: true },
                        wheel: { enabled: true },
                      },
                    },
                  },
                },
              });
            }
            
            // Inicializar com temperatura máxima
            createTempChart('tx');
            
            // Event listeners para os botões
            document.getElementById("showTx").onclick = function() {
              if (window.currentChart) window.currentChart.destroy();
              createTempChart('tx');
              this.classList.add('bg-red-200');
              document.getElementById("showTn").classList.remove('bg-blue-200');
            };
            
            document.getElementById("showTn").onclick = function() {
              if (window.currentChart) window.currentChart.destroy();
              createTempChart('tn');
              this.classList.add('bg-blue-200');
              document.getElementById("showTx").classList.remove('bg-red-200');
            };
            
            // Marcar botão inicial como ativo
            document.getElementById("showTx").classList.add('bg-red-200');
            
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
          });
        });
      }

      // Função para desenhar marcadores de caudal
      function drawCaudalMarkers() {
        clearMarkers();
        Object.entries(caudalData).forEach(([localizacao, station]) => {
          const marker = L.circleMarker(station.coord, {
            radius: 6,
            color: "#17a2b8",
            fillColor: "#17a2b8",
            fillOpacity: 0.8,
          });
          marker.addTo(markersLayer).on("click", () => {
            document.getElementById("chart-modal").classList.remove("hidden");
            document.getElementById("well-title").innerText = `Estação ${localizacao}`;
            document.getElementById("trendAnalysisBtn").classList.add("hidden");
            const ctx = document.getElementById("wellChart").getContext("2d");
            if (window.currentChart) window.currentChart.destroy();
            // Ordenar os dados por data antes de plotar
            const sortedData = station.data
              .slice()
              .sort((a, b) => new Date(a.date) - new Date(b.date));
            window.currentChart = new Chart(ctx, {
              type: "line",
              data: {
                datasets: [
                  {
                    label: "Caudal médio diário (m³/s)",
                    data: sortedData.map((d) => ({
                      x: d.date,
                      y: d.caudal,
                    })),
                    borderColor: "#17a2b8",
                    backgroundColor: "rgba(23,162,184,0.2)",
                    fill: "start",
                    tension: 0.2,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    type: "time",
                    time: {
                      unit: "year",
                      tooltipFormat: "yyyy-MM-dd",
                    },
                    title: { display: true, text: "Data" },
                  },
                  y: {
                    title: { display: true, text: "Caudal (m³/s)" },
                    min: 0,
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
            document.getElementById("resetZoomBtn").onclick = function () {
              if (window.currentChart) window.currentChart.resetZoom();
            };
            document.getElementById("trendStatsBox").classList.add("hidden");
            document.getElementById("trendStatsBox").innerHTML = "";
          });
        });
      }

      // Função para limpar valores de nitrato com caracteres especiais
      function cleanNitrateValue(value) {
        if (typeof value === "string") {
          value = value.replace(/\(e<\)|\(<\)/g, "");
        }
        var num = parseFloat(value);
        return isNaN(num) ? 0 : num;
      }

      // Carregar e processar o CSV de profundidade
      function loadProfundidadeData(callback) {
        Papa.parse("resources/model_data/piezo/piezo_model_al.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const data = results.data;
            const wells = {};
            data.forEach((row) => {
              if (!row.codigo || row.codigo === "377/287") return; // Skip well 377/287
              if (!wells[row.codigo]) {
                const [lon, lat] = convertCoords(row.coord_x_m, row.coord_y_m);
                wells[row.codigo] = {
                  coord: [lat, lon],
                  data: [],
                };
              }
              wells[row.codigo].data.push({
                date: row.data,
                profundidade: parseFloat(row.profundidade_nivel_agua),
              });
            });
            wellsData = wells;
            if (callback) callback();
          },
        });
      }

      // Carregar e processar o CSV de nitrato
      function loadNitratoData(callback) {
        Papa.parse("resources/model_data/nitrato/nitrato_model_al.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const data = results.data;
            const nitratos = {};
            data.forEach((row) => {
              if (!row.codigo) return;
              if (!nitratos[row.codigo]) {
                const [lon, lat] = convertCoords(row.coord_x_m, row.coord_y_m);
                nitratos[row.codigo] = {
                  coord: [lat, lon],
                  data: [],
                };
              }
              // Converter data para string ISO e guardar
              let dateStr = row.data ? row.data.substring(0, 10) : "";
              nitratos[row.codigo].data.push({
                date: dateStr,
                nitrato: cleanNitrateValue(row.nitrato),
              });
            });
            // Ordenar os dados de cada poço por data
            Object.values(nitratos).forEach((well) => {
              well.data.sort((a, b) => new Date(a.date) - new Date(b.date));
            });
            nitratoData = nitratos;
            if (callback) callback();
          },
        });
      }

      // Carregar e processar o CSV de precipitação
      function loadPrecipData(callback) {
        Papa.parse("resources/model_data/precip/prec_model_al.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const data = results.data;
            const stations = {};
            data.forEach((row) => {
              if (!row.codigo) return;
              if (!stations[row.codigo]) {
                const [lon, lat] = convertCoords(row.coord_x_m, row.coord_y_m);
                stations[row.codigo] = {
                  coord: [lat, lon],
                  nome: row.nome,
                  data: [],
                };
              }
              // Converter data para string ISO e guardar
              let dateStr = row.data ? row.data.substring(0, 10) : "";
              stations[row.codigo].data.push({
                date: dateStr,
                precipitacao: parseFloat(row.precipitacao_dia_mm),
              });
            });
            // Ordenar os dados de cada estação por data
            Object.values(stations).forEach((station) => {
              station.data.sort((a, b) => new Date(a.date) - new Date(b.date));
            });
            precipData = stations;
            if (callback) callback();
          },
        });
      }

      // Carregar e processar o CSV de rega
      function loadRegaData(callback) {
        Papa.parse("resources/model_data/rega/consumos_de_agua.csv", {
          download: true,
          header: true,
          delimiter: ";",
          complete: function (results) {
            const data = results.data;
            const regas = {};
            data.forEach((row) => {
              if (!row.Municipio || !row.Lat || !row.Long || row.Ano == "2022") return;
              // Corrigir vírgula para ponto nas coordenadas
              const lat = parseFloat(row.Lat.replace(',', '.'));
              const lon = parseFloat(row.Long.replace(',', '.'));
              if (isNaN(lat) || isNaN(lon)) return;
              if (!regas[row.Municipio]) {
                regas[row.Municipio] = {
                  coord: [lat, lon],
                  data: [],
                };
              }
              // Corrigir volume para hm3
              const volume = parseFloat(row["Volume rega hm3"].replace(',', '.'));
              regas[row.Municipio].data.push({
                date: row.Ano,
                volume: isNaN(volume) ? null : volume,
              });
            });
            // Ordenar os dados por data
            Object.values(regas).forEach((municipio) => {
              municipio.data.sort((a, b) => a.date - b.date);
            });
            regaData = regas;
            if (callback) callback();
          },
        });
      }

      // Carregar e processar o CSV de temperaturas
      function loadTempData(callback) {
        Papa.parse("https://raw.githubusercontent.com/clepsydraisa/clepsydra_isa/refs/heads/main/resources/model_data/temp_eobs/temp_2014_2024_eobs.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const data = results.data;
            const temps = {};
            data.forEach((row) => {
              if (!row.Time || !row.lat || !row.long) return;
              
              // Criar chave única para cada localização
              const locationKey = `${row.lat}_${row.long}`;
              
              if (!temps[locationKey]) {
                temps[locationKey] = {
                  coord: [parseFloat(row.lat), parseFloat(row.long)],
                  data: [],
                };
              }
              
              // Converter data para string ISO
              let dateStr = row.Time ? row.Time.substring(0, 10) : "";
              temps[locationKey].data.push({
                date: dateStr,
                tx: parseFloat(row.tx) || null, // Temperatura máxima
                tn: parseFloat(row.tn) || null, // Temperatura mínima
              });
            });
            
            // Ordenar os dados de cada localização por data
            Object.values(temps).forEach((location) => {
              location.data.sort((a, b) => new Date(a.date) - new Date(b.date));
            });
            
            tempData = temps;
            if (callback) callback();
          },
        });
      }

      // Função para limpar valores de caudal (remove (vau), aspas, espaços)
      function cleanCaudalValue(value) {
        if (typeof value === "string") {
          value = value.replace(/\(vau\)/gi, "").replace(/\"/g, "").trim();
        }
        var num = parseFloat(value);
        return isNaN(num) ? null : num;
      }

      // Carregar e processar o CSV de caudal
      function loadCaudalData(callback) {
        Papa.parse("resources/model_data/caudal/caudal.csv", {
          download: true,
          header: true,
          complete: function (results) {
            const data = results.data;
            const stations = {};
            data.forEach((row) => {
              if (!row.localização) return;
              if (!stations[row.localização]) {
                const [lon, lat] = convertCoords(row.coord_x_m, row.coord_y_m);
                stations[row.localização] = {
                  coord: [lat, lon],
                  data: [],
                };
              }
              // Converter data para string ISO e guardar
              let dateStr = row.Data ? row.Data.substring(0, 10) : "";
              const caudalValue = cleanCaudalValue(row["ALMOUROL (17G/02H)_Caudal médio diário (m3/s)"]);
              if (caudalValue !== null) {
                stations[row.localização].data.push({
                  date: dateStr,
                  caudal: caudalValue,
                });
              }
            });
            // Ordenar os dados de cada estação por data
            Object.values(stations).forEach((station) => {
              station.data.sort((a, b) => new Date(a.date) - new Date(b.date));
            });
            caudalData = stations;
            if (callback) callback();
          },
        });
      }

      // Atualizar filtro de poço/código conforme variável
      function updateWellFilter() {
        const variable = document.getElementById("variableFilter").value;
        const wellFilter = document.getElementById("wellFilter");
        let codes = [];
        if (variable === "profundidade" && wellsData) {
          codes = Object.keys(wellsData);
        } else if (variable === "nitrato" && nitratoData) {
          codes = Object.keys(nitratoData);
        } else if (variable === "precipitacao" && precipData) {
          codes = Object.keys(precipData);
        } else if (variable === "rega" && regaData) {
          codes = Object.keys(regaData);
        } else if (variable === "temperaturas" && tempData) {
          codes = Object.keys(tempData);
        } else if (variable === "caudal" && caudalData) {
          codes = Object.keys(caudalData);
        } else {
          document.getElementById("infoTableBox").innerHTML = "<i>Nenhum dado disponível.</i>";
          return;
        }
        wellFilter.innerHTML =
          '<option value="">Todos</option>' +
          codes.map((c) => `<option value="${c}">${c}</option>`).join("");
      }

      // Função para dar zoom e abrir modal do poço selecionado
      function focusOnWell(codigo) {
        const variable = document.getElementById("variableFilter").value;
        let obj = null;
        if (variable === "profundidade" && wellsData && wellsData[codigo]) {
          obj = wellsData[codigo];
          map.setView(obj.coord, 14);
          // Simula clique no marcador
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById("well-title").innerText = `Poço ${codigo}`;
          document.getElementById("trendAnalysisBtn").textContent =
            "Análise de tendência";
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          window.currentChart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [
                {
                  label: "Profundidade Nível Água (m)",
                  data: obj.data.map((d) => ({ x: d.date, y: d.profundidade })),
                  borderColor: "#007bff",
                  backgroundColor: "rgba(0,123,255,0.2)",
                  fill: "start",
                  tension: 0.2,
                },
              ],
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "year",
                    tooltipFormat: "yyyy-MM-dd",
                  },
                  title: { display: true, text: "Data" },
                },
                y: {
                  title: { display: true, text: "Profundidade (m)" },
                  reverse: true,
                  min: 0,
                },
              },
              plugins: {
                zoom: {
                  pan: { enabled: true, mode: "x", modifierKey: null },
                  zoom: {
                    enabled: true,
                    mode: "x",
                    drag: { enabled: true },
                    wheel: { enabled: true },
                  },
                },
              },
            },
          });
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
          // Mostrar botão de análise de tendência apenas para piezometria
          document
            .getElementById("trendAnalysisBtn")
            .classList.remove("hidden");
          document.getElementById("trendStatsBox").classList.add("hidden");
          document.getElementById("trendStatsBox").innerHTML = "";
          let trendVisible = false;
          document.getElementById("trendAnalysisBtn").onclick =
            async function () {
              if (!trendVisible) {
                const jsonUrl = `resources/trends/trends_piezo/trend_${codigo.replace(
                  "/",
                  "_"
                )}.json`;
                try {
                  const resp = await fetch(jsonUrl);
                  if (!resp.ok) throw new Error("Trend JSON não encontrado");
                  const trendData = await resp.json();
                  // Adicionar linhas de tendência ao gráfico
                  if (window.currentChart) {
                    const mainDataset =
                      window.currentChart.data.datasets.filter(
                        (ds) => !ds._isTrend
                      );
                    const trendDatasets = trendData.segments.map(
                      (seg, idx) => ({
                        label: `Período ${idx + 1}`,
                        data: seg.trend_points.map((p) => ({
                          x: p.x,
                          y: -p.y,
                        })),
                        borderColor: "#e67e22",
                        backgroundColor: "rgba(230,126,34,0.1)",
                        borderDash: [6, 3],
                        pointRadius: 0,
                        fill: false,
                        tension: 0,
                        _isTrend: true,
                        order: 99,
                        type: "line",
                      })
                    );
                    window.currentChart.data.datasets =
                      mainDataset.concat(trendDatasets);
                    window.currentChart.update();
                  }
                  // Mostrar estatísticas na box
                  let html = `<div class="trend-title">Análise de tendência</div>`;
                  trendData.segments.forEach((seg, idx) => {
                    html += getTrendDescription(seg, idx, "profundidade");
                  });
                  document.getElementById("trendStatsBox").innerHTML = html;
                  document
                    .getElementById("trendStatsBox")
                    .classList.remove("hidden");
                  trendVisible = true;
                  this.textContent = "Fechar análise de tendência";
                } catch (e) {
                  document.getElementById("trendStatsBox").innerHTML =
                    '<span class="text-red-600">Erro ao carregar análise de tendência.</span>';
                  document
                    .getElementById("trendStatsBox")
                    .classList.remove("hidden");
                  trendVisible = true;
                  this.textContent = "Fechar análise de tendência";
                }
              } else {
                // Esconder linhas de tendência e box
                if (window.currentChart) {
                  window.currentChart.data.datasets =
                    window.currentChart.data.datasets.filter(
                      (ds) => !ds._isTrend
                    );
                  window.currentChart.update();
                }
                document
                  .getElementById("trendStatsBox")
                  .classList.add("hidden");
                document.getElementById("trendStatsBox").innerHTML = "";
                trendVisible = false;
                this.textContent = "Análise de tendência";
              }
            };
        } else if (
          variable === "nitrato" &&
          nitratoData &&
          nitratoData[codigo]
        ) {
          obj = nitratoData[codigo];
          map.setView(obj.coord, 14);
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById("well-title").innerText = `Poço ${codigo}`;
          document.getElementById("trendAnalysisBtn").textContent =
            "Análise de tendência";
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          window.currentChart = new Chart(ctx, {
            type: "scatter",
            data: {
              datasets: [
                {
                  label: "Nitrato (mg/L)",
                  data: obj.data.map((d) => ({ x: d.date, y: d.nitrato })),
                  borderColor: "#28a745",
                  backgroundColor: "#28a745",
                  showLine: false,
                  pointRadius: 4,
                  pointHoverRadius: 6,
                },
              ],
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "year",
                    tooltipFormat: "yyyy-MM-dd",
                  },
                  title: { display: true, text: "Data" },
                },
                y: {
                  title: { display: true, text: "Nitrato (mg/L)" },
                  min: 0,
                },
              },
              plugins: {
                zoom: {
                  pan: { enabled: true, mode: "x", modifierKey: null },
                  zoom: {
                    enabled: true,
                    mode: "x",
                    drag: { enabled: true },
                    wheel: { enabled: true },
                  },
                },
              },
            },
          });
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
          // Mostrar botão de análise de tendência para nitrato
          document
            .getElementById("trendAnalysisBtn")
            .classList.remove("hidden");
          document.getElementById("trendStatsBox").classList.add("hidden");
          document.getElementById("trendStatsBox").innerHTML = "";
          let trendVisible = false;
          document.getElementById("trendAnalysisBtn").onclick =
            async function () {
              if (!trendVisible) {
                const jsonUrl = `resources/trends/trends_nitrato/trend_${codigo.replace(
                  "/",
                  "_"
                )}.json`;
                try {
                  const resp = await fetch(jsonUrl);
                  if (!resp.ok) throw new Error("Trend JSON não encontrado");
                  const trendData = await resp.json();
                  // Adicionar linhas de tendência ao gráfico
                  if (window.currentChart) {
                    const mainDataset =
                      window.currentChart.data.datasets.filter(
                        (ds) => !ds._isTrend
                      );
                    const trendDatasets = trendData.segments.map(
                      (seg, idx) => ({
                        label: `Período ${idx + 1}`,
                        data: seg.trend_points, // NÃO inverter sinal!
                        borderColor: "#e67e22",
                        backgroundColor: "rgba(230,126,34,0.1)",
                        borderDash: [6, 3],
                        pointRadius: 0,
                        fill: false,
                        tension: 0,
                        _isTrend: true,
                        order: 99,
                        type: "line",
                      })
                    );
                    window.currentChart.data.datasets =
                      mainDataset.concat(trendDatasets);
                    window.currentChart.update();
                  }
                  // Mostrar estatísticas na box
                  let html = `<div class="trend-title">Análise de tendência</div>`;
                  trendData.segments.forEach((seg, idx) => {
                    html += getTrendDescription(seg, idx, "nitrato");
                  });
                  document.getElementById("trendStatsBox").innerHTML = html;
                  document
                    .getElementById("trendStatsBox")
                    .classList.remove("hidden");
                  trendVisible = true;
                  this.textContent = "Fechar análise de tendência";
                } catch (e) {
                  document.getElementById("trendStatsBox").innerHTML =
                    '<span class="text-red-600">Erro ao carregar análise de tendência.</span>';
                  document
                    .getElementById("trendStatsBox")
                    .classList.remove("hidden");
                  trendVisible = true;
                  this.textContent = "Fechar análise de tendência";
                }
              } else {
                // Esconder linhas de tendência e box
                if (window.currentChart) {
                  window.currentChart.data.datasets =
                    window.currentChart.data.datasets.filter(
                      (ds) => !ds._isTrend
                    );
                  window.currentChart.update();
                }
                document
                  .getElementById("trendStatsBox")
                  .classList.add("hidden");
                document.getElementById("trendStatsBox").innerHTML = "";
                trendVisible = false;
                this.textContent = "Análise de tendência";
              }
            };
        } else if (
          variable === "precipitacao" &&
          precipData &&
          precipData[codigo]
        ) {
          obj = precipData[codigo];
          map.setView(obj.coord, 14);
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById(
            "well-title"
          ).innerText = `Estação ${codigo} - ${obj.nome}`;
          document.getElementById("trendAnalysisBtn").textContent =
            "Análise de tendência";
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          window.currentChart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [
                {
                  label: "Precipitação (mm)",
                  data: obj.data.map((d) => ({ x: d.date, y: d.precipitacao })),
                  borderColor: "#800080",
                  backgroundColor: "rgba(128,0,128,0.2)",
                  fill: "start",
                  tension: 0.2,
                },
              ],
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "year",
                    tooltipFormat: "yyyy-MM-dd",
                  },
                  title: { display: true, text: "Data" },
                },
                y: {
                  title: { display: true, text: "Precipitação (mm)" },
                  min: 0,
                },
              },
              plugins: {
                zoom: {
                  pan: { enabled: true, mode: "x", modifierKey: null },
                  zoom: {
                    enabled: true,
                    mode: "x",
                    drag: { enabled: true },
                    wheel: { enabled: true },
                  },
                },
              },
            },
          });
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
          document.getElementById("trendAnalysisBtn").classList.add("hidden");
          document.getElementById("trendStatsBox").classList.add("hidden");
          document.getElementById("trendStatsBox").innerHTML = "";
        } else if (
          variable === "rega" &&
          regaData &&
          regaData[codigo]
        ) {
          obj = regaData[codigo];
          map.setView(obj.coord, 14);
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById(
            "well-title"
          ).innerText = `Município ${codigo}`;
          document.getElementById("trendAnalysisBtn").classList.add("hidden");
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          window.currentChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels: obj.data.map((d) => d.date),
              datasets: [
                {
                  label: "Volume de Rega (hm³)",
                  data: obj.data.map((d) => d.volume),
                  backgroundColor: "#ff6b1f",
                },
              ],
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  title: { display: true, text: "Ano" },
                },
                y: {
                  title: { display: true, text: "Volume (hm³)" },
                  min: 0,
                },
              },
              plugins: {
                zoom: {
                  pan: { enabled: true, mode: "x", modifierKey: null },
                  zoom: {
                    enabled: true,
                    mode: "x",
                    drag: { enabled: true },
                    wheel: { enabled: true },
                  },
                },
              },
            },
          });
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
          document.getElementById("trendStatsBox").classList.add("hidden");
          document.getElementById("trendStatsBox").innerHTML = "";
        } else if (
          variable === "temperaturas" &&
          tempData &&
          tempData[codigo]
        ) {
          obj = tempData[codigo];
          map.setView(obj.coord, 14);
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById("well-title").innerText = `Localização ${codigo.replace('_', ', ')}`;
          document.getElementById("trendAnalysisBtn").classList.add("hidden");
          
          // Criar botões para alternar entre temperatura máxima e mínima
          const trendStatsBox = document.getElementById("trendStatsBox");
          trendStatsBox.classList.remove("hidden");
          trendStatsBox.innerHTML = `
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-2">Tipo de Temperatura:</label>
              <div class="flex space-x-2">
                <button id="showTx" class="px-3 py-1 bg-red-100 text-red-800 rounded hover:bg-red-200 transition text-sm">
                  Temperatura Máxima
                </button>
                <button id="showTn" class="px-3 py-1 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 transition text-sm">
                  Temperatura Mínima
                </button>
              </div>
            </div>
          `;
          
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          
          // Função para criar gráfico de temperatura
          function createTempChart(tempType) {
            const data = tempType === 'tx' ? obj.data.map(d => ({ x: d.date, y: d.tx })) : obj.data.map(d => ({ x: d.date, y: d.tn }));
            const label = tempType === 'tx' ? 'Temperatura Máxima (°C)' : 'Temperatura Mínima (°C)';
            const color = tempType === 'tx' ? '#dc3545' : '#007bff';
            
            window.currentChart = new Chart(ctx, {
              type: "scatter",
              data: {
                datasets: [
                  {
                    label: label,
                    data: data,
                    borderColor: color,
                    backgroundColor: color,
                    showLine: false,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                  },
                ],
              },
              options: {
                responsive: true,
                scales: {
                  x: {
                    type: "time",
                    time: {
                      unit: "year",
                      tooltipFormat: "yyyy-MM-dd",
                    },
                    title: { display: true, text: "Data" },
                  },
                  y: {
                    title: { display: true, text: "Temperatura (°C)" },
                  },
                },
                plugins: {
                  zoom: {
                    pan: { enabled: true, mode: "x", modifierKey: null },
                    zoom: {
                      enabled: true,
                      mode: "x",
                      drag: { enabled: true },
                      wheel: { enabled: true },
                    },
                  },
                },
              },
            });
          }
          
          // Inicializar com temperatura máxima
          createTempChart('tx');
          
          // Event listeners para os botões
          document.getElementById("showTx").onclick = function() {
            if (window.currentChart) window.currentChart.destroy();
            createTempChart('tx');
            this.classList.add('bg-red-200');
            document.getElementById("showTn").classList.remove('bg-blue-200');
          };
          
          document.getElementById("showTn").onclick = function() {
            if (window.currentChart) window.currentChart.destroy();
            createTempChart('tn');
            this.classList.add('bg-blue-200');
            document.getElementById("showTx").classList.remove('bg-red-200');
          };
          
          // Marcar botão inicial como ativo
          document.getElementById("showTx").classList.add('bg-red-200');
          
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
        } else if (
          variable === "caudal" &&
          caudalData &&
          caudalData[codigo]
        ) {
          obj = caudalData[codigo];
          map.setView(obj.coord, 14);
          document.getElementById("chart-modal").classList.remove("hidden");
          document.getElementById("well-title").innerText = `Estação ${codigo}`;
          document.getElementById("trendAnalysisBtn").classList.add("hidden");
          const ctx = document.getElementById("wellChart").getContext("2d");
          if (window.currentChart) window.currentChart.destroy();
          // Ordenar os dados por data antes de plotar
          const sortedData = obj.data
            .slice()
            .sort((a, b) => new Date(a.date) - new Date(b.date));
          window.currentChart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [
                {
                  label: "Caudal médio diário (m³/s)",
                  data: sortedData.map((d) => ({ x: d.date, y: d.caudal })),
                  borderColor: "#17a2b8",
                  backgroundColor: "rgba(23,162,184,0.2)",
                  fill: "start",
                  tension: 0.2,
                },
              ],
            },
            options: {
              responsive: true,
              scales: {
                x: {
                  type: "time",
                  time: {
                    unit: "year",
                    tooltipFormat: "yyyy-MM-dd",
                  },
                  title: { display: true, text: "Data" },
                },
                y: {
                  title: { display: true, text: "Caudal (m³/s)" },
                  min: 0,
                },
              },
              plugins: {
                zoom: {
                  pan: { enabled: true, mode: "x", modifierKey: null },
                  zoom: {
                    enabled: true,
                    mode: "x",
                    drag: { enabled: true },
                    wheel: { enabled: true },
                  },
                },
              },
            },
          });
          document.getElementById("resetZoomBtn").onclick = function () {
            if (window.currentChart) window.currentChart.resetZoom();
          };
          document.getElementById("trendStatsBox").classList.add("hidden");
          document.getElementById("trendStatsBox").innerHTML = "";
        }
      }

      // Atualizar mapa e filtro de poço ao mudar variável
      function updateMapAndWellFilter() {
        updateMap();
        updateWellFilter();
        if (infoVisible) showInfoTable();
      }

      // Atualizar filtro de poço ao carregar dados
      function updateWellFilterAfterLoad() {
        updateWellFilter();
      }

      // Inicialização
      document.addEventListener("DOMContentLoaded", function () {
        // Reset variable and well filter to default on load
        document.getElementById("variableFilter").value = "profundidade";
        document.getElementById("wellFilter").selectedIndex = 0;
        initMap();
        loadProfundidadeData(function () {
          drawProfundidadeMarkers();
          updateWellFilterAfterLoad();
        }); // Carrega profundidade por padrão
        document
          .getElementById("variableFilter")
          .addEventListener("change", function() {
            updateMapAndWellFilter();
          });
        document
          .getElementById("wellFilter")
          .addEventListener("change", function () {
            const codigo = this.value;
            if (codigo) {
              focusOnWell(codigo);
            } else {
              // Zoom out para a vista inicial
              if (map) map.setView([39.5, -8], 8);
            }
          });
        if (document.getElementById("infoBtn")) {
          document.getElementById("infoBtn").onclick = async function() {
            infoVisible = !infoVisible;
            if (infoVisible) {
              await showInfoTable();
              this.textContent = '× Fechar Info';
            } else {
              document.getElementById("infoTableBox").classList.add("hidden");
              document.getElementById("infoTableBox").innerHTML = "";
              this.textContent = '+ Info';
            }
          };
          // Inicializa o texto do botão
          document.getElementById("infoBtn").textContent = '+ Info';
        }
      });

      // Atualizar filtro de poço ao carregar outros dados
      function loadNitratoDataWithFilter(cb) {
        loadNitratoData(function () {
          if (cb) cb();
          updateWellFilterAfterLoad();
        });
      }
      function loadPrecipDataWithFilter(cb) {
        loadPrecipData(function () {
          if (cb) cb();
          updateWellFilterAfterLoad();
        });
      }
      function loadRegaDataWithFilter(cb) {
        loadRegaData(function () {
          if (cb) cb();
          updateWellFilterAfterLoad();
        });
      }

      function loadTempDataWithFilter(cb) {
        loadTempData(function () {
          if (cb) cb();
          updateWellFilterAfterLoad();
        });
      }

      function loadCaudalDataWithFilter(cb) {
        loadCaudalData(function () {
          if (cb) cb();
          updateWellFilterAfterLoad();
        });
      }

      // Modificar updateMap para usar as funções acima
      function updateMap() {
        const variable = document.getElementById("variableFilter").value;
        if (variable === "profundidade") {
          if (!wellsData)
            loadProfundidadeData(function () {
              drawProfundidadeMarkers();
              updateWellFilterAfterLoad();
            });
          else {
            drawProfundidadeMarkers();
            updateWellFilterAfterLoad();
          }
        } else if (variable === "nitrato") {
          if (!nitratoData) loadNitratoDataWithFilter(drawNitratoMarkers);
          else {
            drawNitratoMarkers();
            updateWellFilterAfterLoad();
          }
        } else if (variable === "precipitacao") {
          if (!precipData) loadPrecipDataWithFilter(drawPrecipMarkers);
          else {
            drawPrecipMarkers();
            updateWellFilterAfterLoad();
          }
        } else if (variable === "rega") {
          if (!regaData) loadRegaDataWithFilter(drawRegaMarkers);
          else {
            drawRegaMarkers();
            updateWellFilterAfterLoad();
          }
        } else if (variable === "temperaturas") {
          if (!tempData) loadTempDataWithFilter(drawTempMarkers);
          else {
            drawTempMarkers();
            updateWellFilterAfterLoad();
          }
        } else if (variable === "caudal") {
          if (!caudalData) loadCaudalDataWithFilter(drawCaudalMarkers);
          else {
            drawCaudalMarkers();
            updateWellFilterAfterLoad();
          }
        } else {
          clearMarkers();
          updateWellFilter();
          // Municípios: estrutura pronta para implementar
        }
      }

      // Adicione a função para mostrar a tabela de info
      async function showInfoTable() {
        const variable = document.getElementById("variableFilter").value;
        let codes = [];
        if (variable === "profundidade" && wellsData) {
          codes = Object.keys(wellsData);
        } else if (variable === "nitrato" && nitratoData) {
          codes = Object.keys(nitratoData);
        } else if (variable === "precipitacao" && precipData) {
          codes = Object.keys(precipData);
        } else if (variable === "rega" && regaData) {
          codes = Object.keys(regaData);
        } else if (variable === "temperaturas" && tempData) {
          codes = Object.keys(tempData);
        } else if (variable === "caudal" && caudalData) {
          codes = Object.keys(caudalData);
        } else {
          document.getElementById("infoTableBox").innerHTML = "<i>Nenhum dado disponível.</i>";
          return;
        }

        // Agrupar segmentos por poço
        let poços = {};
        for (const codigo of codes) {
          let url = variable === "profundidade"
            ? `resources/trends/trends_piezo/trend_${codigo.replace("/", "_")}.json`
            : variable === "nitrato"
              ? `resources/trends/trends_nitrato/trend_${codigo.replace("/", "_")}.json`
              : null;
          
          if (!url) continue;

          try {
            const resp = await fetch(url);
            if (!resp.ok) continue;
            const trendData = await resp.json();
            poços[codigo] = trendData.segments.map((seg, idx) => {
              let tipo = seg.trend_type === "decreasing" ? "Decrescente"
                        : seg.trend_type === "increasing" ? "Crescente"
                        : "Sem tendência";
              return {
                periodo: `${idx + 1}º ${seg.start_date} a ${seg.end_date}`,
                tendencia: `${idx + 1}º ${tipo}`,
                raw_trend: seg.trend_type,
              };
            });
          } catch (e) { /* ignora erros de fetch */ }
        }

        let rows = Object.entries(poços).map(([codigo, segmentos]) => {
          const periodos = segmentos.map(s => s.periodo).join(' | ');
          let tendenciaTexto;

          if (variable === 'profundidade') {
            if (segmentos.length > 0) {
              const ultimaTendenciaRaw = segmentos[segmentos.length - 1].raw_trend;
              if (ultimaTendenciaRaw === 'decreasing') {
                tendenciaTexto = 'Aumento da profundidade';
              } else if (ultimaTendenciaRaw === 'increasing') {
                tendenciaTexto = 'Diminuição da profundidade';
              } else {
                tendenciaTexto = 'Sem alteração';
              }
            } else {
              tendenciaTexto = 'N/A';
            }
          } else {
            tendenciaTexto = segmentos.map(s => s.tendencia).join(' | ');
          }

          return `
            <tr>
              <td class="border px-2 py-1">
                <button class="show-chart-btn" title="Ver gráfico" data-codigo="${codigo}">📈</button>
                ${codigo}
              </td>
              <td class="border px-2 py-1">${periodos}</td>
              <td class="border px-2 py-1">${tendenciaTexto}</td>
            </tr>
          `;
        });

        let tableHtml = `
          <table class="min-w-full border mt-2 text-xs">
            <thead>
              <tr class="bg-gray-100">
                <th class="border px-2 py-1">Poço</th>
                <th class="border px-2 py-1">Período</th>
                <th class="border px-2 py-1">Tendência</th>
              </tr>
            </thead>
            <tbody>
              ${rows.join("")}
            </tbody>
          </table>
        `;

        // RESUMO DE TENDÊNCIAS (só última de cada poço)
        let resumoHtml = "";
        if (variable === 'profundidade') {
            const resumo = { 'Aumento da profundidade': 0, 'Diminuição da profundidade': 0, 'Sem alteração': 0 };
            Object.values(poços).forEach(segmentos => {
                if (!segmentos.length) return;
                const ultimaRaw = segmentos[segmentos.length - 1].raw_trend;
                if (ultimaRaw === 'decreasing') resumo['Aumento da profundidade']++;
                else if (ultimaRaw === 'increasing') resumo['Diminuição da profundidade']++;
                else resumo['Sem alteração']++;
            });
            resumoHtml = `
              <div class="font-semibold text-base mb-1 mt-4 text-center">-- RESUMO --</div>
              <table class="min-w-[300px] border mt-0 text-sm mx-auto">
                <thead><tr class="bg-gray-100"><th class="border px-2 py-1">Tendência</th><th class="border px-2 py-1">Nº de Poços</th></tr></thead>
                <tbody>
                  <tr><td class="border px-2 py-1">Diminuição da profundidade</td><td class="border px-2 py-1">${resumo['Diminuição da profundidade']}</td></tr>
                  <tr><td class="border px-2 py-1">Aumento da profundidade</td><td class="border px-2 py-1">${resumo['Aumento da profundidade']}</td></tr>
                  <tr><td class="border px-2 py-1">Sem alteração</td><td class="border px-2 py-1">${resumo['Sem alteração']}</td></tr>
                </tbody>
              </table>`;
        } else if (variable === 'nitrato') {
            const resumo = { 'Crescente': 0, 'Decrescente': 0, 'Sem tendência': 0 };
            Object.values(poços).forEach(segmentos => {
              if (!segmentos.length) return;
              const ultima = segmentos[segmentos.length - 1].tendencia;
              if (ultima.includes('Crescente')) resumo['Crescente']++;
              else if (ultima.includes('Decrescente')) resumo['Decrescente']++;
              else resumo['Sem tendência']++;
            });
            resumoHtml = `
              <div class="font-semibold text-base mb-1 mt-4 text-center">-- RESUMO --</div>
              <table class="min-w-[300px] border mt-0 text-sm mx-auto">
                <thead><tr class="bg-gray-100"><th class="border px-2 py-1">Tendência</th><th class="border px-2 py-1">Nº de Poços</th></tr></thead>
                <tbody>
                  <tr><td class="border px-2 py-1">Crescente</td><td class="border px-2 py-1">${resumo['Crescente']}</td></tr>
                  <tr><td class="border px-2 py-1">Decrescente</td><td class="border px-2 py-1">${resumo['Decrescente']}</td></tr>
                  <tr><td class="border px-2 py-1">Sem tendência</td><td class="border px-2 py-1">${resumo['Sem tendência']}</td></tr>
                </tbody>
              </table>`;
        }
        
        document.getElementById("infoTableBox").innerHTML = tableHtml + resumoHtml;
        document.getElementById("infoTableBox").classList.remove("hidden");

        // Adicionar event listener para os botões de gráfico
        document.querySelectorAll('.show-chart-btn').forEach(btn => {
          btn.onclick = function(e) {
            const codigo = this.getAttribute('data-codigo');
            focusOnWell(codigo);
          };
        });
      }

      // Adicione o controle do botão Info
      let infoVisible = false;
    </script>
  </body>
</html>
